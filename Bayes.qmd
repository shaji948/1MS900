---
title: "Bayesian Statistics"
format: html
editor: visual
---

# Computational Techniques
## Approximating Posterior Moments
### Independent Monte Carlo

```{r}
#### Independent Monte Carlo ####
## Data
n <- 20
sumy <- 40.4
sumysq <- 93.2
R <- 5e03
## Posterior 
betan <- sumy / (n + 1)
an <- 2 + n / 2
bn <- 2 + 0.5 * (sumysq - ((sumy ^ 2)) / (n + 1))
## Independent Monte Carlo
set.seed(12345)
sigma.sq <- rep(NA, R)
beta <- rep(NA, R)
for(r in 1 : R){
    sigma.sq[r] <- 1 / rgamma(n = 1, shape = an, rate = bn)
    beta[r] <- rnorm(n = 1, mean = betan, sd = sqrt(sigma.sq[r] / (n + 1)))
}
## Plot the results
par(mar = c(4.1, 4.1, 1.5, 1))
plot(cumsum(beta) / (1 : R), type = "l", xlab = "n", ylab = "Independent Monte Carlo approximation")
abline(h = sumy / (n + 1), col = 2, lty = 2, lwd = 2)
```

### Importance Sampling
```{r}
#### Importance Sampling ####
## Data
n <- 20
sumy <- 40.4
ybar <- sumy / 20
sumysq <- 93.2
ysd <- sqrt((sumysq - n * ybar ^ 2) / (n - 1))
## Posterior 
betan <- sumy / (n + 1)
an <- 2 + n / 2
bn <- 2 + 0.5 * (sumysq - ((sumy ^ 2)) / (n + 1))
## Density of inverse-Gamma distribution
IvGamma <- function(x, a, b){
    exp(a * log(b) - lgamma(a) - (a + 1) * log(x) - b / x)
} 
## Monte Carlo
set.seed(123456)
R <- 5e03
h.pi.g <- rep(NA, R)
for(r in 1 : R){
    ## We use Exp(1 / ybar) as the importance distribution
    proposal <- rexp(n = 1, rate = 1 / ybar)
    ## Compute the value of h(theta) * pi(theta | data) / g(theta)
    h.pi.g[r] <- proposal * IvGamma(proposal, an, bn) / dexp(proposal, rate = 1 / ybar)
}
## Plot the results
par(mar = c(4.1, 4.1, 1.5, 1))
plot(cumsum(h.pi.g) / (1 : R), type = "l", xlab = "n", ylab = "Importance Sampling")
abline(h = bn / (an - 1), col = 2, lty = 2, lwd = 2)
```


### Normalized Importance Sampling
```{r}
#### Normalized Importance Sampling ####
set.seed(123456)
w <- rep(NA, R)
NIS <- rep(NA, R)
for(r in 1 : R){
    ## Simulate sigma and beta
    sigma.sq <- rexp(n = 1, rate = 1 / ybar)
    beta <- rnorm(n = 1, mean = ybar, sd = ysd)
    ## Compute the densities
    posterior <- exp(-0.5 * ((n + 1) * beta ^ 2 - 2 * beta * sumy + 4 + sumysq) / sigma.sq) / (sigma.sq ^ (0.5 * (n + 1) + 3))
    g.density <- dnorm(x = beta, mean = ybar, sd = ysd) * dexp(x = sigma.sq, rate = 1 / ybar)
    ## normalized IS estimator
    w[r] <- posterior / g.density
    NIS[r] <- w[r] * sigma.sq
}
## Plot the results
par(mar = c(4.1, 4.1, 1.5, 1))
plot(cumsum(NIS) / cumsum(w), type = "l", xlab = "n", ylab = "Normalized Importance Sampling")
abline(h = bn / (an - 1), col = 2, lty = 2, lwd = 2)

```


## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:

```{r}
1 + 1
```

You can add options to executable code like this

```{r}
#| echo: false
2 * 2
```

The `echo: false` option disables the printing of code (only output is displayed).
