{
  "hash": "ecb1ac4b09c5f1f59e23ba984fc33855",
  "result": {
    "markdown": "---\ntitle: \"Bayesian Statistics\"\nformat: html\neditor: visual\n---\n\n\n# Computational Techniques\n## Approximating Posterior Moments\n### Independent Monte Carlo\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#### Independent Monte Carlo ####\n## Data\nn <- 20\nsumy <- 40.4\nsumysq <- 93.2\nR <- 5e03\n## Posterior \nbetan <- sumy / (n + 1)\nan <- 2 + n / 2\nbn <- 2 + 0.5 * (sumysq - ((sumy ^ 2)) / (n + 1))\n## Independent Monte Carlo\nset.seed(12345)\nsigma.sq <- rep(NA, R)\nbeta <- rep(NA, R)\nfor(r in 1 : R){\n    sigma.sq[r] <- 1 / rgamma(n = 1, shape = an, rate = bn)\n    beta[r] <- rnorm(n = 1, mean = betan, sd = sqrt(sigma.sq[r] / (n + 1)))\n}\n## Plot the results\npar(mar = c(4.1, 4.1, 1.5, 1))\nplot(cumsum(beta) / (1 : R), type = \"l\", xlab = \"n\", ylab = \"Independent Monte Carlo approximation\")\nabline(h = sumy / (n + 1), col = 2, lty = 2, lwd = 2)\n```\n\n::: {.cell-output-display}\n![](Bayes_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n### Importance Sampling\n\n::: {.cell}\n\n```{.r .cell-code}\n#### Importance Sampling ####\n## Data\nn <- 20\nsumy <- 40.4\nybar <- sumy / 20\nsumysq <- 93.2\nysd <- sqrt((sumysq - n * ybar ^ 2) / (n - 1))\n## Posterior \nbetan <- sumy / (n + 1)\nan <- 2 + n / 2\nbn <- 2 + 0.5 * (sumysq - ((sumy ^ 2)) / (n + 1))\n## Density of inverse-Gamma distribution\nIvGamma <- function(x, a, b){\n    exp(a * log(b) - lgamma(a) - (a + 1) * log(x) - b / x)\n} \n## Monte Carlo\nset.seed(123456)\nR <- 5e03\nh.pi.g <- rep(NA, R)\nfor(r in 1 : R){\n    ## We use Exp(1 / ybar) as the importance distribution\n    proposal <- rexp(n = 1, rate = 1 / ybar)\n    ## Compute the value of h(theta) * pi(theta | data) / g(theta)\n    h.pi.g[r] <- proposal * IvGamma(proposal, an, bn) / dexp(proposal, rate = 1 / ybar)\n}\n## Plot the results\npar(mar = c(4.1, 4.1, 1.5, 1))\nplot(cumsum(h.pi.g) / (1 : R), type = \"l\", xlab = \"n\", ylab = \"Importance Sampling\")\nabline(h = bn / (an - 1), col = 2, lty = 2, lwd = 2)\n```\n\n::: {.cell-output-display}\n![](Bayes_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\n### Normalized Importance Sampling\n\n::: {.cell}\n\n```{.r .cell-code}\n#### Normalized Importance Sampling ####\nset.seed(123456)\nw <- rep(NA, R)\nNIS <- rep(NA, R)\nfor(r in 1 : R){\n    ## Simulate sigma and beta\n    sigma.sq <- rexp(n = 1, rate = 1 / ybar)\n    beta <- rnorm(n = 1, mean = ybar, sd = ysd)\n    ## Compute the densities\n    posterior <- exp(-0.5 * ((n + 1) * beta ^ 2 - 2 * beta * sumy + 4 + sumysq) / sigma.sq) / (sigma.sq ^ (0.5 * (n + 1) + 3))\n    g.density <- dnorm(x = beta, mean = ybar, sd = ysd) * dexp(x = sigma.sq, rate = 1 / ybar)\n    ## normalized IS estimator\n    w[r] <- posterior / g.density\n    NIS[r] <- w[r] * sigma.sq\n}\n## Plot the results\npar(mar = c(4.1, 4.1, 1.5, 1))\nplot(cumsum(NIS) / cumsum(w), type = \"l\", xlab = \"n\", ylab = \"Normalized Importance Sampling\")\nabline(h = bn / (an - 1), col = 2, lty = 2, lwd = 2)\n```\n\n::: {.cell-output-display}\n![](Bayes_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n## Sampling from Posterior Distribution\n### Metropolis-Hastings Algorithm\n\n::: {.cell}\n\n```{.r .cell-code}\n#### Metropolis-Hastings Algorithm ####\n## Data\nn <- 20\nsumy <- 40.4\nsumysq <- 93.2\nybar <- sumy / n\nysd <- sqrt((sumysq - n * ybar ^ 2) / (n - 1))\n## Define function for posterior density\nposterior <- function(beta, sigma.sq) {\n    exp(-0.5 * ((n + 1) * beta ^ 2 - 2 * beta * sumy + 4 + sumysq) / sigma.sq) / \n        (sigma.sq ^ (0.5 * (n + 1) + 3))\n}\n## Define function for Metropolis-Hastings algorithm\nMHalgorithm <- function(L, initial, sd) {   \n    # L is the length of the Markov chain, including the burn-in period\n    # initial is the initial state\n    # sd is the standard deviation of the proposal distribution for beta\n    chain <- rbind(c(initial), matrix(NA, L, length(initial)))\n    for(t in 1 : L){\n        # Propose a candidate\n        beta.prop <- rnorm(n = 1, mean = chain[t, 1], sd = sd)\n        sigmasq.prop <- rexp(n = 1, rate = 1 / chain[t, 2])\n        # Calculate the ratio\n        numerator <- posterior(beta = beta.prop, sigma.sq = sigmasq.prop) * \n            dnorm(x = chain[t, 1], mean = beta.prop, sd = sd) * \n            dexp(x = chain[t, 2], rate = 1 / sigmasq.prop)\n        denominator <- posterior(beta = chain[t, 1], sigma.sq = chain[t, 2]) * \n            dnorm(x = beta.prop, mean = chain[t, 1], sd = sd) * \n            dexp(x = sigmasq.prop, rate = 1 / chain[t, 2])\n        r <- numerator / denominator\n        # Generate U(0, 1)\n        u <- runif(1, 0, 1)\n        # Update\n        if(u <= r) {     \n            chain[t + 1, ] <- c(beta.prop, sigmasq.prop)\n        } else {     \n            chain[t + 1, ] <- chain[t, ]       \n        }\n    }\n    chain\n}\n## Perform MCMC sampling\nset.seed(12345)\nMH <- MHalgorithm(L = 20000, initial = c(0, 1), sd = 0.2) # sd is a tuning parameter\npar(mfrow = c(2, 1), mar = c(4.1, 4.1, 1.5, 1)) \nplot(MH[, 1], type = \"l\", ylab = expression(beta))  \nplot(MH[, 2], type = \"l\", ylab = expression(sigma^2))\n```\n\n::: {.cell-output-display}\n![](Bayes_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Bayes_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}